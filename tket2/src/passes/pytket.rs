//! This module contains routines needed for normalizing a circuit
//! into a form that can be encoded as a pytket legacy circuit.
//!
//! This is a best-effort attempt, and may not always succeed.

use derive_more::{Display, Error, From};
use hugr::hugr::views::ExtractHugr;
use hugr::Node;
use itertools::Itertools;

use crate::serialize::pytket::OpConvertError;
use crate::Circuit;

use super::find_tuple_unpack_rewrites;

/// Try to lower a circuit to a form that can be encoded as a pytket legacy circuit.
pub fn lower_to_pytket<T: ExtractHugr<Node = Node>>(
    circ: &Circuit<T>,
) -> Result<Circuit, PytketLoweringError> {
    let mut circ = circ
        .extract_dfg()
        .map_err(|_| PytketLoweringError::NonLocalOperations)?;

    // Remove sequences of tuple pack-unpack operations,
    // typically generated by guppy.
    let rewrites = find_tuple_unpack_rewrites(&circ).collect_vec();
    for rewrite in rewrites {
        rewrite.apply(&mut circ).unwrap();
    }

    Ok(circ)
}

/// Errors that can occur during the lowering process.
#[derive(Debug, Display, Error, From)]
#[non_exhaustive]
pub enum PytketLoweringError {
    /// An error occurred during the conversion of an operation.
    #[display("operation conversion error: {_0}")]
    #[from]
    OpConversionError(OpConvertError),
    /// The circuit is not fully-contained in a region.
    /// Function calls are not supported.
    #[display("Non-local operations found. Function calls are not supported.")]
    NonLocalOperations,
}

#[cfg(test)]
mod test {

    use crate::Tk2Op;

    use super::*;
    use hugr::builder::{
        Container, Dataflow, DataflowSubContainer, HugrBuilder, ModuleBuilder, SubContainer,
    };
    use hugr::extension::prelude::{qb_t, MakeTuple, UnpackTuple};

    use hugr::ops::handle::NodeHandle;
    use hugr::ops::{OpType, Tag};
    use hugr::types::{Signature, TypeRow};
    use hugr::HugrView;
    use rstest::{fixture, rstest};

    /// Builds a circuit in the style of guppy's output.
    ///
    /// This is composed of a `Module`, containing a `FuncDefn`, containing a
    /// `CFG`, containing an `Exit` and a `DataflowBlock` with the actual
    /// circuit.
    #[fixture]
    fn guppy_like_circuit() -> Circuit {
        fn build() -> Result<Circuit, hugr::builder::BuildError> {
            let two_qbs = TypeRow::from(vec![qb_t(), qb_t()]);
            let circ_signature = Signature::new_endo(two_qbs.clone());
            let circ;

            let mut builder = ModuleBuilder::new();
            let _func = {
                let mut func = builder.define_function("main", circ_signature)?;
                let [q1, q2] = func.input_wires_arr();

                let cfg = {
                    let mut cfg =
                        func.cfg_builder([(qb_t(), q1), (qb_t(), q2)], two_qbs.clone())?;

                    circ = {
                        let mut dfg = cfg.simple_entry_builder(two_qbs.clone(), 1)?;
                        let [q1, q2] = dfg.input_wires_arr();

                        let [q1] = dfg.add_dataflow_op(Tk2Op::H, [q1])?.outputs_arr();
                        let [q1, q2] = dfg.add_dataflow_op(Tk2Op::CX, [q1, q2])?.outputs_arr();

                        let [tup] = dfg
                            .add_dataflow_op(MakeTuple::new(two_qbs.clone()), [q1, q2])?
                            .outputs_arr();
                        let [q1, q2] = dfg
                            .add_dataflow_op(UnpackTuple::new(two_qbs), [tup])?
                            .outputs_arr();

                        // Adds an empty Unit branch.
                        let [branch] = dfg
                            .add_dataflow_op(Tag::new(0, vec![TypeRow::new()]), [])?
                            .outputs_arr();

                        dfg.finish_with_outputs(branch, [q1, q2])?
                    };
                    cfg.branch(&circ, 0, &cfg.exit_block())?;

                    cfg.finish_sub_container()?
                };
                let [q1, q2] = cfg.outputs_arr();

                func.finish_with_outputs([q1, q2])?
            };

            let hugr = builder.finish_hugr()?;
            Ok(Circuit::new(hugr, circ.node()))
        }
        build().unwrap()
    }

    #[rstest]
    #[case::guppy_like_circuit(guppy_like_circuit())]
    fn test_pytket_lowering(#[case] circ: Circuit) {
        use cool_asserts::assert_matches;

        let lowered_circ = lower_to_pytket(&circ).unwrap();
        lowered_circ.hugr().validate().unwrap();

        assert_eq!(lowered_circ.parent(), lowered_circ.hugr().root());
        assert_matches!(
            lowered_circ.hugr().get_optype(lowered_circ.parent()),
            OpType::DFG(_)
        );
        assert_matches!(
            lowered_circ.hugr().get_optype(lowered_circ.input_node()),
            OpType::Input(_)
        );
        assert_matches!(
            lowered_circ.hugr().get_optype(lowered_circ.output_node()),
            OpType::Output(_)
        );
        assert_eq!(lowered_circ.num_operations(), circ.num_operations());

        // Check that the circuit signature is preserved.
        let original_sig = circ.circuit_signature();
        let lowered_sig = lowered_circ.circuit_signature();
        assert_eq!(lowered_sig.input(), original_sig.input());

        // The output signature may have changed due CFG branch tag removal.
        let output_count_diff =
            original_sig.output().len() as isize - lowered_sig.output().len() as isize;
        assert!(
            output_count_diff == 0 || output_count_diff == 1,
            "Output count mismatch. Original: {}, Lowered: {}",
            original_sig,
            lowered_sig
        );
        assert_eq!(
            lowered_sig.output()[..],
            original_sig.output()[output_count_diff as usize..]
        );

        // Check that the output node was successfully updated
        let output_sig = lowered_circ
            .hugr()
            .signature(lowered_circ.output_node())
            .unwrap();
        assert_eq!(lowered_sig.output(), output_sig.input());
    }
}
